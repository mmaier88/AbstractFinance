"""
Core data types for the execution package.

Provides structured representations for:
- Market data snapshots (bid/ask/last/close)
- Order intents (what we want to trade)
- Order plans (how we'll execute)
- Order tickets (lifecycle tracking)
- Execution results (fill outcomes)
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from enum import Enum


class OrderStatus(Enum):
    """Order lifecycle states."""
    NEW = "NEW"
    SUBMITTED = "SUBMITTED"
    PARTIAL = "PARTIAL"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"
    PENDING_CANCEL = "PENDING_CANCEL"
    PENDING_REPLACE = "PENDING_REPLACE"


class OrderType(Enum):
    """Supported order types."""
    LMT = "LMT"           # Limit order
    MKT = "MKT"           # Market order (restricted)
    MOO = "MOO"           # Market on Open
    MOC = "MOC"           # Market on Close
    LOO = "LOO"           # Limit on Open
    LOC = "LOC"           # Limit on Close
    ALGO = "ALGO"         # Algorithmic order (VWAP, TWAP, etc.)


class TimeInForce(Enum):
    """Time in force options."""
    DAY = "DAY"
    IOC = "IOC"           # Immediate or Cancel
    GTC = "GTC"           # Good Till Cancelled
    OPG = "OPG"           # At the Opening
    CLS = "CLS"           # At the Close


class Urgency(Enum):
    """Order urgency levels."""
    LOW = "low"           # Can wait for better price
    NORMAL = "normal"     # Standard execution
    HIGH = "high"         # Prioritize fill speed
    CRISIS = "crisis"     # Emergency - fill immediately


@dataclass(frozen=True)
class MarketDataSnapshot:
    """
    Point-in-time market data for execution decisions.

    Rules:
    - If bid/ask missing, may fall back to last/close for marking
    - DO NOT TRADE unless policy explicitly allows missing quotes
    - Freshness check required before execution
    """
    symbol: str
    ts: datetime

    last: Optional[float] = None
    bid: Optional[float] = None
    ask: Optional[float] = None
    close: Optional[float] = None
    volume: Optional[int] = None
    avg_daily_volume: Optional[int] = None

    @property
    def mid(self) -> Optional[float]:
        """Mid price from bid/ask."""
        if self.bid is not None and self.ask is not None:
            return (self.bid + self.ask) / 2.0
        return None

    @property
    def spread(self) -> Optional[float]:
        """Bid-ask spread."""
        if self.bid is not None and self.ask is not None:
            return self.ask - self.bid
        return None

    @property
    def spread_bps(self) -> Optional[float]:
        """Spread in basis points."""
        if self.mid and self.spread:
            return (self.spread / self.mid) * 10000.0
        return None

    @property
    def reference_price(self) -> Optional[float]:
        """Best available reference price for limit calculation."""
        return self.mid or self.last or self.close

    def is_fresh(self, max_age_seconds: int = 30) -> bool:
        """Check if data is fresh enough for trading."""
        if self.ts is None:
            return False
        age = (datetime.now() - self.ts).total_seconds()
        return age <= max_age_seconds

    def has_quotes(self) -> bool:
        """Check if bid/ask are present."""
        return self.bid is not None and self.ask is not None


@dataclass
class OrderIntent:
    """
    High-level trading intent from strategy.

    This is what the strategy wants to achieve, separate from
    how it will be executed. Execution policy converts intents
    into concrete order plans.
    """
    instrument_id: str
    side: str                           # "BUY" or "SELL"
    quantity: int
    reason: str                         # "rebalance", "hedge", "roll", "crisis"
    sleeve: str                         # Which strategy sleeve
    urgency: Urgency = Urgency.NORMAL
    limit_hint: Optional[float] = None  # Strategy-suggested limit
    notional_usd: Optional[float] = None  # For sizing checks
    pair_group: Optional[str] = None    # Link to paired trades

    def __post_init__(self):
        if isinstance(self.urgency, str):
            self.urgency = Urgency(self.urgency)


@dataclass
class OrderPlan:
    """
    Concrete execution plan for an order.

    Generated by ExecutionPolicy from OrderIntent + MarketDataSnapshot.
    Contains all parameters needed to submit and manage the order.
    """
    order_type: OrderType
    limit_price: Optional[float]
    tif: TimeInForce
    algo: Optional[str] = None          # "Adaptive", "VWAP", "TWAP"
    algo_params: Optional[Dict[str, Any]] = None
    max_slippage_bps: float = 10.0
    ttl_seconds: int = 120
    replace_interval_seconds: int = 15
    max_replace_attempts: int = 6

    # Collar bounds (hard limits)
    price_ceiling: Optional[float] = None  # Max price for BUY
    price_floor: Optional[float] = None    # Min price for SELL

    def __post_init__(self):
        if isinstance(self.order_type, str):
            self.order_type = OrderType(self.order_type)
        if isinstance(self.tif, str):
            self.tif = TimeInForce(self.tif)


@dataclass
class OrderTicket:
    """
    Tracks an order through its lifecycle.

    The OrderManager maintains tickets and updates them as
    orders progress through submission, fills, replaces, etc.
    """
    intent: OrderIntent
    plan: OrderPlan
    ticket_id: str = ""                 # Internal tracking ID

    # Timing
    created_at: datetime = field(default_factory=datetime.now)
    submitted_at: Optional[datetime] = None
    last_replace_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    # Lifecycle tracking
    replace_count: int = 0
    cancel_attempts: int = 0

    # Fill tracking
    filled_qty: int = 0
    remaining_qty: int = 0
    avg_fill_price: Optional[float] = None
    total_commission: float = 0.0

    # Status
    status: OrderStatus = OrderStatus.NEW
    broker_order_id: Optional[int] = None
    broker_status: Optional[str] = None
    last_error: Optional[str] = None

    # Reference prices for slippage calculation
    arrival_price: Optional[float] = None
    arrival_mid: Optional[float] = None

    def __post_init__(self):
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
        self.remaining_qty = self.intent.quantity - self.filled_qty

    @property
    def is_terminal(self) -> bool:
        """Check if order is in a terminal state."""
        return self.status in (
            OrderStatus.FILLED,
            OrderStatus.CANCELLED,
            OrderStatus.REJECTED,
            OrderStatus.EXPIRED
        )

    @property
    def is_active(self) -> bool:
        """Check if order is active (submitted and not terminal)."""
        return self.status in (
            OrderStatus.SUBMITTED,
            OrderStatus.PARTIAL,
            OrderStatus.PENDING_REPLACE
        )

    @property
    def fill_pct(self) -> float:
        """Percentage of order filled."""
        if self.intent.quantity == 0:
            return 0.0
        return self.filled_qty / self.intent.quantity

    @property
    def slippage_bps(self) -> Optional[float]:
        """Slippage vs arrival price in basis points."""
        if self.arrival_price is None or self.avg_fill_price is None:
            return None
        if self.arrival_price == 0:
            return None

        if self.intent.side == "BUY":
            # Positive = paid more than arrival
            slip = (self.avg_fill_price - self.arrival_price) / self.arrival_price
        else:
            # Positive = received less than arrival
            slip = (self.arrival_price - self.avg_fill_price) / self.arrival_price

        return slip * 10000.0

    def elapsed_seconds(self) -> float:
        """Seconds since order was submitted."""
        if self.submitted_at is None:
            return 0.0
        return (datetime.now() - self.submitted_at).total_seconds()


@dataclass
class ExecutionResult:
    """
    Summary of a completed execution.

    Returned by OrderManager when an order reaches a terminal state.
    """
    ticket: OrderTicket
    success: bool
    fill_qty: int
    avg_price: Optional[float]
    slippage_bps: Optional[float]
    commission: float
    elapsed_seconds: float
    replace_count: int
    error: Optional[str] = None

    @classmethod
    def from_ticket(cls, ticket: OrderTicket) -> "ExecutionResult":
        """Create result from completed ticket."""
        return cls(
            ticket=ticket,
            success=ticket.status == OrderStatus.FILLED,
            fill_qty=ticket.filled_qty,
            avg_price=ticket.avg_fill_price,
            slippage_bps=ticket.slippage_bps,
            commission=ticket.total_commission,
            elapsed_seconds=ticket.elapsed_seconds(),
            replace_count=ticket.replace_count,
            error=ticket.last_error
        )


@dataclass
class PairGroup:
    """
    Groups related orders for coordinated execution.

    Used to manage legging risk when trading pairs or
    multi-leg strategies.
    """
    name: str
    intents: List[OrderIntent]
    hedge_intent: Optional[OrderIntent] = None  # Emergency hedge instrument
    max_legging_seconds: int = 60
    trigger_fill_pct: float = 0.30               # Trigger hedge if one leg fills this much

    # Execution state
    tickets: List[OrderTicket] = field(default_factory=list)
    hedge_ticket: Optional[OrderTicket] = None
    started_at: Optional[datetime] = None

    def is_legged(self) -> bool:
        """Check if execution has significant legging risk."""
        if len(self.tickets) < 2:
            return False

        fill_pcts = [t.fill_pct for t in self.tickets]
        max_fill = max(fill_pcts)
        min_fill = min(fill_pcts)

        # Legged if one leg is significantly ahead
        return max_fill >= self.trigger_fill_pct and min_fill < 0.1

    def needs_hedge(self) -> bool:
        """Check if temporary hedge is needed."""
        if self.hedge_intent is None:
            return False
        if self.hedge_ticket is not None:
            return False  # Already hedged
        return self.is_legged()

    def elapsed_seconds(self) -> float:
        """Seconds since pair execution started."""
        if self.started_at is None:
            return 0.0
        return (datetime.now() - self.started_at).total_seconds()
